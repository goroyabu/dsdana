/**
  @file WriteHittreeAll.cpp
  @author Goro Yabu
  @date 2019/06/23
  @version 1.0
  @note This file is generated by mkwritetree.
**/
#include "WriteHittreeAll.hpp"

WriteHittreeAll::WriteHittreeAll() :
    ANLModuleBase("WriteHittreeAll", "1.0"),
    m_file(nullptr), m_tree(nullptr),
    m_file_name("in.root"), m_tree_name("TTree")
{
}

void WriteHittreeAll::mod_init(int &status)
{
    status = anlcross::ANL_OK;
    
    m_file = OpenTFile(m_file_name, "recreate");
    if( !m_file ) status = anlcross::ANL_NG;
    
    if( status == anlcross::ANL_OK ){
	m_tree = new TTree(m_tree_name.c_str(), m_tree_name.c_str());
    }
    
    if( status == anlcross::ANL_OK )
	status = set_write_branch();
}

void WriteHittreeAll::mod_com(int &status)
{
    status = anlcross::ANL_OK;
    com_cli::read_value<std::string>("Output ROOT TFile Name ?", &m_file_name);
    com_cli::read_value<std::string>("            TTree Name ?", &m_tree_name);
}

void WriteHittreeAll::mod_ana(int &status)
{
    status = anlcross::ANL_OK;
    int nbytes;
    if( status == anlcross::ANL_OK ) nbytes = m_tree->Fill();
    if( nbytes<0 ) status = anlcross::ANL_NG;
}

void WriteHittreeAll::mod_exit(int &status)
{
    status = anlcross::ANL_OK;
    if( m_file!=nullptr ){
        m_file->cd();
        m_tree->Write(); std::cout << " Write TTree " << m_tree->GetName() << std::endl;
        m_file->Close(); std::cout << " Close TFile " << m_file->GetName() << std::endl;
    }
}

TFile * WriteHittreeAll::OpenTFile(std::string name, std::string option)
{
    TFile * file = new TFile(name.c_str(), option.c_str());
    if( !file || file->IsZombie() ) return nullptr;
    std::cout << "WriteHittreeAll::OpenTFile ";
    std::cout << name << std::endl;
    return file;
}

int WriteHittreeAll::set_write_branch()
{
    define_branch<unsigned int>("livetime", "livetime/i");
    define_branch<unsigned int>("unixtime", "unixtime/i");
    define_branch<unsigned int>("ti_upper", "ti_upper/i");
    define_branch<unsigned int>("ti_lower", "ti_lower/i");
    define_branch<unsigned int>("ext1ti_upper", "ext1ti_upper/i");
    define_branch<unsigned int>("ext1ti_lower", "ext1ti_lower/i");
    define_branch<unsigned int>("ext2ti_upper", "ext2ti_upper/i");
    define_branch<unsigned int>("ext2ti_lower", "ext2ti_lower/i");
    define_branch<int>("nsignal_x_lv1", "nsignal_x_lv1/I");
    define_branch<int>("nsignal_y_lv1", "nsignal_y_lv1/I");
    define_branch<int>("detid_x_lv1", "detid_x_lv1[nsignal_x_lv1]/I");
    define_branch<int>("detid_y_lv1", "detid_y_lv1[nsignal_y_lv1]/I");
    define_branch<int>("stripid_x_lv1", "stripid_x_lv1[nsignal_x_lv1]/I");
    define_branch<int>("stripid_y_lv1", "stripid_y_lv1[nsignal_y_lv1]/I");
    define_branch<float>("epi_x_lv1", "epi_x_lv1[nsignal_x_lv1]/F");
    define_branch<float>("epi_y_lv1", "epi_y_lv1[nsignal_y_lv1]/F");
    define_branch<int>("nsignal_x_lv2", "nsignal_x_lv2/I");
    define_branch<int>("nsignal_y_lv2", "nsignal_y_lv2/I");
    define_branch<int>("detid_x_lv2", "detid_x_lv2[nsignal_x_lv2]/I");
    define_branch<int>("detid_y_lv2", "detid_y_lv2[nsignal_y_lv2]/I");
    define_branch<float>("epi_x_lv2", "epi_x_lv2[nsignal_x_lv2]/F");
    define_branch<float>("epi_y_lv2", "epi_y_lv2[nsignal_y_lv2]/F");
    define_branch<float>("pos_x_lv2", "pos_x_lv2[nsignal_x_lv2]/F");
    define_branch<float>("pos_y_lv2", "pos_y_lv2[nsignal_y_lv2]/F");
    define_branch<float>("width_x_lv2", "width_x_lv2[nsignal_x_lv2]/F");
    define_branch<float>("width_y_lv2", "width_y_lv2[nsignal_y_lv2]/F");
    define_branch<int>("n_merged_strips_x_lv2", "n_merged_strips_x_lv2[nsignal_x_lv2]/I");
    define_branch<int>("n_merged_strips_y_lv2", "n_merged_strips_y_lv2[nsignal_y_lv2]/I");
    define_branch<int>("n_lv1signal_x_lv2", "n_lv1signal_x_lv2/I");
    define_branch<int>("n_lv1signal_y_lv2", "n_lv1signal_y_lv2/I");
    define_branch<int>("lv1signal_id_x_lv2", "lv1signal_id_x_lv2[n_lv1signal_x_lv2]/I");
    define_branch<int>("lv1signal_id_y_lv2", "lv1signal_id_y_lv2[n_lv1signal_y_lv2]/I");
    define_branch<int>("nhit_lv3", "nhit_lv3/I");
    define_branch<int>("detid_lv3", "detid_lv3[nhit_lv3]/I");
    define_branch<float>("epi_lv3", "epi_lv3[nhit_lv3]/F");
    define_branch<float>("epi_x_lv3", "epi_x_lv3[nhit_lv3]/F");
    define_branch<float>("epi_y_lv3", "epi_y_lv3[nhit_lv3]/F");
    define_branch<float>("pos_x_lv3", "pos_x_lv3[nhit_lv3]/F");
    define_branch<float>("pos_y_lv3", "pos_y_lv3[nhit_lv3]/F");
    define_branch<float>("pos_z_lv3", "pos_z_lv3[nhit_lv3]/F");
    define_branch<float>("width_x_lv3", "width_x_lv3[nhit_lv3]/F");
    define_branch<float>("width_y_lv3", "width_y_lv3[nhit_lv3]/F");
    define_branch<float>("width_z_lv3", "width_z_lv3[nhit_lv3]/F");
    define_branch<int>("n_lv2signal_x_lv3", "n_lv2signal_x_lv3/I");
    define_branch<int>("n_lv2signal_y_lv3", "n_lv2signal_y_lv3/I");
    define_branch<int>("lv2signal_id_x_lv3", "lv2signal_id_x_lv3[n_lv2signal_x_lv3]/I");
    define_branch<int>("lv2signal_id_y_lv3", "lv2signal_id_y_lv3[n_lv2signal_y_lv3]/I");

    return anlcross::ANL_OK;
}

